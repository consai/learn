
136. 只出现一次的数字
func singleNumber(nums []int) int {
    if len(nums) == 1{
        return nums[0]
    }
    sort.Ints(nums)
    for i := 1; i <len(nums); i++{
        if nums[i] == nums[i-1]{
            i++
        }else{
            return nums[i-1]
        }
    }
    return nums[len(nums)-1]
}


9. 回文数
func isPalindrome(x int) bool {
    s := strconv.Itoa(x)
    for i,j :=0, len(s)-1; i<j; {
        if s[i] != s[j]{
            return false
        }
        i++
        j--
    }
    return true    
}

20. 有效的括号
func isValid(s string) bool {
   a := []rune{}
	for _, v := range s {
		switch v {
		case '(', '{', '[':
			a = append(a, v)
		case '}':
			if len(a) == 0 || a[len(a)-1] != '{' {
				return false
			} else {
				a = a[:len(a)-1]
			}
		case ']':
			if len(a) == 0 || a[len(a)-1] != '[' {
				return false
			} else {
				a = a[:len(a)-1]
			}
		case ')':
			if len(a) == 0 || a[len(a)-1] != '(' {
				return false
			} else {
				a = a[:len(a)-1]
			}
		}
	}
	return len(a) == 0
}



14. 最长公共前缀
func longestCommonPrefix(strs []string) string {
	com := []rune{}
	for i, v := range strs[0] {
		for j := 1; j < len(strs); j++ {
			if len(strs[j]) <= i || strs[0][i] != strs[j][i] {
				return string(com)
			}
		}
		com = append(com, v)
	}
	return string(com)
}

加一
func plusOne(digits []int) []int {
    
	for i := len(digits) - 1; i >= 0; i-- {
		if digits[i] == 9 {
			digits[i] = 0
		} else {
			digits[i] += 1
			return digits
		}
	}
	digits[0] = 1
	digits = append(digits, 0)
	return digits
}

26. 删除有序数组中的重复项
func removeDuplicates(nums []int) int {
    j := 0
	for i := range nums {
		if i > 0 {
			if nums[i] != nums[j] {
				j++
				nums[j] = nums[i]
			}
		}
	}
	return j+1
}


合并区间
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0{
        return intervals
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0] 
    })
    
    j:=0
    for _, v:= range intervals[1:]{
        if v[0]<=intervals[j][1]{
            intervals[j][1] = max(v[1],  intervals[j][1])
        }else{
            j++
            intervals[j] = v
        }
    }
    return intervals[:j+1]
}

1. 两数之和
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, v:= range(nums){
        j, ok := m[target - v]
        if ok{
            return []int{i,j}
        }else{
            m[v] = i        
        }        
    }
    return []int{}
}